#include <iostream>
#include <fstream> // Для работы с файлами
using namespace std;

// ========================== ПРОТОТИПЫ ФУНКЦИЙ ==========================

// Функция для ввода целочисленной матрицы 7x4 из текстового файла.
// Аргументы:
//   filename — имя файла с матрицей.
//   matrix — двумерный массив 7x4, куда будут записаны значения.
// Возвращает true, если ввод прошёл успешно, иначе false (файл не найден или недостаточно данных).
bool inputMatrixFromFile(const char* filename, int matrix[7][4]);

// Функция для вывода матрицы на экран в виде таблицы.
// Аргументы:
//   matrix — двумерный массив 7x4, который выводится на экран.
void printMatrix(const int matrix[7][4]);

// Функция для поиска минимального и максимального элементов в матрице и их индексов.
// Аргументы:
//   matrix — двумерный массив 7x4, где проводится поиск.
//   minRow, minCol — индексы минимального элемента (выходные параметры по ссылке).
//   maxRow, maxCol — индексы максимального элемента (выходные параметры по ссылке).
void findMinMax(const int matrix[7][4], int &minRow, int &minCol, int &maxRow, int &maxCol);

// Функция для обмена местами минимального и максимального элементов.
// Аргументы:
//   matrix — двумерный массив 7x4, где производится обмен.
//   minRow, minCol — индексы минимального элемента.
//   maxRow, maxCol — индексы максимального элемента.
void swapElements(int matrix[7][4], int minRow, int minCol, int maxRow, int maxCol);

// ============================ ОСНОВНАЯ ПРОГРАММА ============================

int main() {
    // Объявляем двумерный массив для хранения матрицы размером 7 строк и 4 столбца
    int matrix[7][4];

    // Имя файла, из которого будет производиться чтение матрицы
    const char* filename = "matrix.txt";

    // Вводим элементы матрицы из файла
    if (!inputMatrixFromFile(filename, matrix)) {
        // Если функция возвращает false — произошла ошибка (например, файл не найден)
        cout << "Ошибка при чтении файла " << filename << endl;
        return 1; // Завершаем выполнение программы с кодом ошибки
    }

    // Выводим исходную матрицу на экран
    cout << "Исходная матрица:" << endl;
    printMatrix(matrix);

    // Переменные для хранения индексов минимального и максимального элементов
    int minRow, minCol, maxRow, maxCol;

    // Находим минимальный и максимальный элементы и их индексы
    findMinMax(matrix, minRow, minCol, maxRow, maxCol);

    // Выводим значения минимального и максимального элементов и их позиции
    cout << "\nМинимальный элемент: " << matrix[minRow][minCol]
         << " (строка " << minRow << ", столбец " << minCol << ")" << endl;
    cout << "Максимальный элемент: " << matrix[maxRow][maxCol]
         << " (строка " << maxRow << ", столбец " << maxCol << ")" << endl;

    // Меняем местами найденные минимальный и максимальный элементы
    swapElements(matrix, minRow, minCol, maxRow, maxCol);

    // Выводим матрицу после обмена элементов
    cout << "\nМатрица после обмена минимального и максимального элементов:" << endl;
    printMatrix(matrix);

    return 0; // Успешное завершение программы
}

// ========================= РЕАЛИЗАЦИЯ ФУНКЦИЙ =========================

// --- ВВОД МАТРИЦЫ ИЗ ФАЙЛА ---
// Открывает файл с именем filename для чтения с помощью fstream.
// Считывает поочередно 7*4 = 28 целых чисел в двумерный массив matrix.
// Если в файле недостаточно чисел или файл не открылся — возвращает false.
bool inputMatrixFromFile(const char* filename, int matrix[7][4]) {
    ifstream fin(filename); // Открываем файл для чтения
    if (!fin.is_open()) {
        // Если файл не удалось открыть, возвращаем ошибку
        return false;
    }
    // Переменная для подсчёта успешно считанных элементов
    int count = 0;
    // Считываем элементы по строкам и столбцам
    for (int i = 0; i < 7; ++i) {
        for (int j = 0; j < 4; ++j) {
            if (!(fin >> matrix[i][j])) {
                // Если не удалось считать очередное число — ошибка
                fin.close();
                return false;
            }
            ++count;
        }
    }
    fin.close(); // Закрываем файл
    // Если считано не 28 элементов — ошибка
    if (count != 28) return false;
    return true; // Ввод прошёл успешно
}

// --- ВЫВОД МАТРИЦЫ НА ЭКРАН ---
// Просто последовательно выводит элементы по строкам, между числами ставит табуляцию.
void printMatrix(const int matrix[7][4]) {
    for (int i = 0; i < 7; ++i) {         // Перебираем все строки
        for (int j = 0; j < 4; ++j) {     // Для каждой строки перебираем столбцы
            cout << matrix[i][j] << "\t"; // Выводим очередной элемент и табуляцию
        }
        cout << endl;                     // После строки переходим на новую строку
    }
}

// --- ПОИСК min/max ЭЛЕМЕНТОВ И ИХ ИНДЕКСОВ ---
// Изначально минимум и максимум — первый элемент [0][0].
// Далее перебирает все элементы и при нахождении меньшего/большего обновляет индексы.
void findMinMax(const int matrix[7][4], int &minRow, int &minCol, int &maxRow, int &maxCol) {
    minRow = 0; minCol = 0; // Индексы начального минимума
    maxRow = 0; maxCol = 0; // Индексы начального максимума
    // Перебираем все элементы матрицы
    for (int i = 0; i < 7; ++i) {
        for (int j = 0; j < 4; ++j) {
            if (matrix[i][j] < matrix[minRow][minCol]) {
                // Если нашли элемент меньше текущего минимума — обновляем индексы минимума
                minRow = i;
                minCol = j;
            }
            if (matrix[i][j] > matrix[maxRow][maxCol]) {
                // Если нашли элемент больше текущего максимума — обновляем индексы максимума
                maxRow = i;
                maxCol = j;
            }
        }
    }
}

// --- ОБМЕН МЕСТАМИ min/max ЭЛЕМЕНТОВ ---
// Использует временную переменную для обмена значениями.
void swapElements(int matrix[7][4], int minRow, int minCol, int maxRow, int maxCol) {
    int temp = matrix[minRow][minCol];            // Сохраняем значение минимального элемента
    matrix[minRow][minCol] = matrix[maxRow][maxCol]; // На его место кладём максимальный
    matrix[maxRow][maxCol] = temp;                // На место максимального кладём бывший минимальный
}
